package test

import (
	"fmt"
	"time"

	. "github.com/go-yaaf/yaaf-common/entity"
	"golang.org/x/exp/rand"
)

// FlowRecord represents a single flow record from the CSV data
// generated by Suricata-based parser
type FlowRecord struct {
	BaseEntity
	StreamId      string `json:"stream_id"       bq:"stream_id"`
	FlowId        int64  `json:"flow_id"         bq:"flow_id"`         // Unique identifier for the flow
	DeviceId      string `json:"device_id"       bq:"device_id"`       // ID of the device
	StartTime     int64  `json:"start_time"      bq:"start_time"`      // Start time of the flow in epoch milliseconds
	EndTime       int64  `json:"end_time"        bq:"end_time"`        // End time of the flow in epoch milliseconds
	SrcIP         string `json:"src_ip"          bq:"src_ip"`          // Source IP address
	SrcPort       int    `json:"src_port"        bq:"src_port"`        // Source port number
	DstIP         string `json:"dst_ip"          bq:"dst_ip"`          // Destination IP address
	DstPort       int    `json:"dst_port"        bq:"dst_port"`        // Destination port number
	PcktToSrv     int    `json:"pckt_to_srv"     bq:"pckt_to_srv"`     // Packets sent to the server
	PcktToClient  int    `json:"pckt_to_client"  bq:"pckt_to_client"`  // Packets sent to the client
	BytesToSrv    int    `json:"bytes_to_srv"    bq:"bytes_to_srv" `   // Bytes sent to the server
	BytesToClient int    `json:"bytes_to_client" bq:"bytes_to_client"` // Bytes sent to the client
	Protocol      string `json:"protocol"        bq:"protocol"`        // Protocol used (e.g., TCP, UDP)
	Pcap          string `json:"pcap"            bq:"pcap" `           // Associated PCAP file name
	Alerted       bool   `json:"alerted"         bq:"alerted"`         // Whether the flow triggered an alert
}

func (f *FlowRecord) TABLE() string { return fmt.Sprintf("flow-data-%s", f.StreamId) }
func (f *FlowRecord) KEY() string   { return fmt.Sprintf("flow-data-%s", f.StreamId) }

func NewFlowRecordEntity(streamId string) EntityFactory {
	return func() Entity {
		shardKey := streamId
		return &FlowRecord{
			StreamId: shardKey,
		}
	}

}

// GenerateFlowRecords generates a specified number of FlowRecords and returns them as a slice
func generateFlowRecords(count int) []Entity {
	dstIPList := []string{
		"1.0.0.1", "103.235.46.96", "103.235.46.98", "103.235.47.188", "104.115.34.40",
		"104.17.111.223", "104.18.41.41", "104.18.8.54", "104.18.9.54", "104.21.17.143",
		// Add all other IPs from the provided list here...
		"216.58.215.164", "3.5.70.154",
	}
	protocols := []string{"TCP", "UDP", "ICMP"}
	streamIDs := []string{"etecnic-1", "etecnic-2", "etecnic-3"}

	rand.Seed(uint64(time.Now().UnixNano())) // Seed random number generator

	var records []Entity

	for i := 1; i <= count; i++ {
		//startTime := time.Now().Add(time.Duration(-rand.Intn(1_000_000)) * time.Second).UnixMilli()
		//endTime := startTime + int64(rand.Intn(300_000)) // Random duration between start and end

		record := &FlowRecord{
			FlowId:   int64(i),
			DeviceId: fmt.Sprintf("device-%d", rand.Intn(100)),
			//StartTime:     startTime / 1000,
			//EndTime:       endTime / 1000,
			SrcIP:         fmt.Sprintf("10.%d.%d.%d", rand.Intn(256), rand.Intn(256), rand.Intn(256)), // Random IP in 10.0.0.0/8
			SrcPort:       rand.Intn(65535),
			DstIP:         dstIPList[rand.Intn(len(dstIPList))], // Random IP from the given list
			DstPort:       rand.Intn(65535),
			PcktToSrv:     rand.Intn(1000),
			PcktToClient:  rand.Intn(1000),
			BytesToSrv:    rand.Intn(1_000_000),
			BytesToClient: rand.Intn(1_000_000),
			Protocol:      protocols[rand.Intn(len(protocols))],
			Pcap:          fmt.Sprintf("trace-%d.pcap", rand.Intn(100)),
			Alerted:       false, // Random true/false
			StreamId:      streamIDs[rand.Intn(len(streamIDs))],
		}
		records = append(records, record)
	}

	return records
}
